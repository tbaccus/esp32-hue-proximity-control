/**
 * @file hue_https_request_instance.c
 * @author Tanner Baccus
 * @date 24 December 2023
 * @brief Implementation for all functions related to the creation of Hue HTTPS request instances
 */

#include "esp_log.h"

#include "hue_https.h"
#include "hue_https_private.h"
#include "hue_helpers.h"

static const char* tag = "hue_https_request";

/*====================================================================================================================*/
/*========================================== Private Function Declarations ===========================================*/
/*====================================================================================================================*/

/**
 * @brief Verifies that resource ID is in the format specified by the Philips Hue API
 *
 * @param[in] resource_id Resource ID to check
 *
 * @return ESP Error code
 * @retval - @c ESP_OK – Resource ID formatted as expected
 * @retval - @c ESP_FAIL – Resource ID incorrectly formatted
 */
static esp_err_t check_resource_id(char* resource_id);

/**
 * @brief Frees all request instance resources and sets handle to NULL
 *
 * @param[in,out] p_request_handle Pointer to request instance handle (value will be set to NULL after)
 *
 * @note p_request_handle is a pointer to a pointer to a request instance, this is used to force the handle to be set to
 * NULL so deallocated memory cannot be accessed with the handle
 */
static void free_request_instance(hue_https_request_handle_t* p_request_handle);

/**
 * @brief Allocates memory for the body of the HTTP request based on the size of the JSON in the buffer and copies over
 * the JSON from the buffer
 *
 * @param[in,out] request_handle Handle for the request instance to create the body for
 * @param[in] p_json_buffer JSON buffer filled by hue_json_builder from hue data structure
 *
 * @return ESP Error code
 * @retval - @c ESP_OK – Request body successfully allocated and filled
 * @retval - @c ESP_ERR_INVALID_ARG – request_handle, p_json_buffer, or p_json_buffer's internal buffer are NULL
 * @retval - @c ESP_ERR_INVALID_SIZE – Data in p_json_buffer is empty/out of buffer range or JSON did not copy correctly
 * @retval - @c ESP_ERR_NO_MEM – Failed to allocate memory for request body
 */
static esp_err_t alloc_request_body(hue_https_request_handle_t request_handle, hue_json_buffer_t* p_json_buffer);

/**
 * @brief Allocates memory for the resource path of the HTTP request URL based on the size of the resource type and ID
 * strings stored in p_json_buffer
 *
 * @param[in,out] request_handle Handle for the request instance to create the resource path for
 * @param[in] p_json_buffer JSON buffer filled by hue_json_builder from hue data structure
 *
 * @return ESP Error code
 * @retval - @c ESP_OK – Resource path successfully allocated and filled
 * @retval - @c ESP_ERR_INVALID_ARG – request_handle, p_json_buffer, or resource type/ID from p_json_buffer are NULL
 * @retval - @c ESP_ERR_INVALID_SIZE – Resource type/ID strings are of unexpected length or resource path print failed
 * @retval - @c ESP_ERR_NO_MEM – Failed to allocate memory for resource
 */
static esp_err_t alloc_resource_path(hue_https_request_handle_t request_handle, hue_json_buffer_t* p_json_buffer);

/**
 * @brief Allocates all memory for request instance and fills the request body and resource path buffers with data from
 * p_json_buffer
 *
 * @param[out] p_request_handle Request handle to store instance into to be used with hue https instance
 * @param[in] p_json_buffer JSON generated by hue_json_builder using hue data structure
 *
 * @return ESP Error code
 * @retval - @c ESP_OK – Request instance successfully allocated and filled
 * @retval - @c ESP_ERR_INVALID_ARG – p_request_handle, p_json_buffer, or p_json_buffer's internal pointers are NULL
 * @retval - @c ESP_ERR_INVALID_SIZE – Data in p_json_buffer is out of expected bounds or request instance buffers
 * failed to be copied to
 * @retval - @c ESP_ERR_NO_MEM – Failed to allocate memory for request instance
 */
static esp_err_t alloc_request_instance(hue_https_request_handle_t* p_request_handle, hue_json_buffer_t* p_json_buffer);

/*====================================================================================================================*/
/*=========================================== Public Function Definitions ============================================*/
/*====================================================================================================================*/

esp_err_t hue_https_create_light_request(hue_https_request_handle_t* p_request_handle, hue_light_data_t* p_light_data) {
    if (HUE_NULL_CHECK(tag, p_request_handle)) return ESP_ERR_INVALID_ARG;
    if (*p_request_handle) {
        ESP_LOGE(tag, "Request handle already created, destroy previous handle before re-creating");
        return ESP_ERR_INVALID_ARG;
    }
    if (HUE_NULL_CHECK(tag, p_light_data)) return ESP_ERR_INVALID_ARG;
    if (HUE_NULL_CHECK(tag, p_light_data->resource_id)) return ESP_ERR_INVALID_ARG;

    /* Verify that resource ID given is in the correct format */
    if (check_resource_id(p_light_data->resource_id) != ESP_OK) return ESP_ERR_INVALID_ARG;

    /* Generate JSON from p_light_data */
    hue_json_buffer_t json_buffer;
    esp_err_t err = hue_light_data_to_json(&json_buffer, p_light_data);
    if (err != ESP_OK) return err;

    /* Allocate and fill request instance */
    return alloc_request_instance(p_request_handle, &json_buffer);
}

esp_err_t hue_https_create_grouped_light_request(hue_https_request_handle_t* p_request_handle,
                                                 hue_grouped_light_data_t* p_grouped_light_data) {
    if (HUE_NULL_CHECK(tag, p_request_handle)) return ESP_ERR_INVALID_ARG;
    if (*p_request_handle) {
        ESP_LOGE(tag, "Request handle already created, destroy previous handle before re-creating");
        return ESP_ERR_INVALID_ARG;
    }
    if (HUE_NULL_CHECK(tag, p_grouped_light_data)) return ESP_ERR_INVALID_ARG;
    if (HUE_NULL_CHECK(tag, p_grouped_light_data->resource_id)) return ESP_ERR_INVALID_ARG;

    /* Verify that resource ID given is in the correct format */
    if (check_resource_id(p_grouped_light_data->resource_id) != ESP_OK) return ESP_ERR_INVALID_ARG;

    /* Generate JSON from p_grouped_light_data */
    hue_json_buffer_t json_buffer;
    esp_err_t err = hue_grouped_light_data_to_json(&json_buffer, p_grouped_light_data);
    if (err != ESP_OK) return err;

    /* Allocate and fill request instance */
    return alloc_request_instance(p_request_handle, &json_buffer);
}

esp_err_t hue_https_create_smart_scene_request(hue_https_request_handle_t* p_request_handle,
                                               hue_smart_scene_data_t* p_smart_scene_data) {
    if (HUE_NULL_CHECK(tag, p_request_handle)) return ESP_ERR_INVALID_ARG;
    if (*p_request_handle) {
        ESP_LOGE(tag, "Request handle already created, destroy previous handle before re-creating");
        return ESP_ERR_INVALID_ARG;
    }
    if (HUE_NULL_CHECK(tag, p_smart_scene_data)) return ESP_ERR_INVALID_ARG;
    if (HUE_NULL_CHECK(tag, p_smart_scene_data->resource_id)) return ESP_ERR_INVALID_ARG;

    /* Verify that resource ID given is in the correct format */
    if (check_resource_id(p_smart_scene_data->resource_id) != ESP_OK) return ESP_ERR_INVALID_ARG;

    /* Generate JSON from p_smart_scene_data */
    hue_json_buffer_t json_buffer;
    esp_err_t err = hue_smart_scene_data_to_json(&json_buffer, p_smart_scene_data);
    if (err != ESP_OK) return err;

    /* Allocate and fill request instance */
    return alloc_request_instance(p_request_handle, &json_buffer);
}

/* TODO: destructor */
esp_err_t hue_https_destroy_request(hue_https_request_handle_t* p_request_handle) { return ESP_ERR_NOT_FINISHED; }

/*====================================================================================================================*/
/*=========================================== Private Function Definitions ===========================================*/
/*====================================================================================================================*/

static esp_err_t check_resource_id(char* resource_id) {
    if (strlen(resource_id) != HUE_RESOURCE_ID_LENGTH) {
        ESP_LOGE(tag, "Resource ID provided is not the correct length for a resource ID");
        return ESP_FAIL;
    }

    /* Storage for the number of correctly formatted characters scanned */
    int chars_received = 0;

    /* Scans the resource ID against the specified format, storing the number of characters scanned */
    sscanf(resource_id, HUE_RESOURCE_ID_FORMAT "%n", &chars_received);

    /* All characters should match the specified format */
    if (chars_received != HUE_RESOURCE_ID_LENGTH) {
        ESP_LOGE(tag, "Resource ID provided is not in the correct format for a resource ID");
        return ESP_FAIL;
    }

    /* Resource ID passed the check */
    return ESP_OK;
}

static void free_request_instance(hue_https_request_handle_t* p_request_handle) {
    /* If p_request_handle or request handle are already NULL, nothing needs to be done */
    if (!p_request_handle) return;
    if (!(*p_request_handle)) return;

    /* Free any resources that are allocated */
    if ((*p_request_handle)->request_body) free((*p_request_handle)->request_body);
    if ((*p_request_handle)->resource_path) free((*p_request_handle)->resource_path);

    /* Free the request instance */
    free(*p_request_handle);

    /* Sets the value of the request handle to NULL to ensure handle cannot be used to access deallocated memory */
    *p_request_handle = NULL;
}

static esp_err_t alloc_request_body(hue_https_request_handle_t request_handle, hue_json_buffer_t* p_json_buffer) {
    if (HUE_NULL_CHECK(tag, request_handle)) return ESP_ERR_INVALID_ARG;
    if (HUE_NULL_CHECK(tag, p_json_buffer)) return ESP_ERR_INVALID_ARG;
    if (HUE_NULL_CHECK(tag, p_json_buffer->buff)) return ESP_ERR_INVALID_ARG;

    /* Get the size of the JSON generated for the request */
    size_t str_len = strlen(p_json_buffer->buff);

    if (str_len == 0) { /* Buffer exists but is empty */
        ESP_LOGE(tag, "JSON buffer not filled");
        return ESP_ERR_INVALID_SIZE;
    } else if (str_len >= HUE_JSON_BUFFER_SIZE) { /* Prevent copying out of bounds without null-terminating character */
        ESP_LOGE(tag, "JSON buffer has no null-terminating character");
        return ESP_ERR_INVALID_SIZE;
    }

    /* If request body is already allocated, free before overwriting pointer */
    if (request_handle->request_body) free(request_handle->request_body);

    /* Allocate request body to exactly fit the JSON generated for the request */
    request_handle->request_body = calloc(str_len + 1, sizeof(char));
    if (!request_handle->request_body) {
        ESP_LOGE(tag, "Failed to allocate memory for request body");
        return ESP_ERR_NO_MEM;
    }

    /* Copy the generated JSON over to the request body buffer */
    strncpy(request_handle->request_body, p_json_buffer->buff, str_len);

    /* Redundant checking to ensure that JSON has been fully copied */
    if (unlikely(strlen(request_handle->request_body) != str_len)) {
        ESP_LOGE(tag, "Failed to copy JSON to request handle");
        return ESP_ERR_INVALID_SIZE;
    }

    return ESP_OK;
}

static esp_err_t alloc_resource_path(hue_https_request_handle_t request_handle, hue_json_buffer_t* p_json_buffer) {
    if (HUE_NULL_CHECK(tag, request_handle)) return ESP_ERR_INVALID_ARG;
    if (HUE_NULL_CHECK(tag, p_json_buffer)) return ESP_ERR_INVALID_ARG;
    if (HUE_NULL_CHECK(tag, p_json_buffer->resource_type)) return ESP_ERR_INVALID_ARG;
    if (HUE_NULL_CHECK(tag, p_json_buffer->resource_id)) return ESP_ERR_INVALID_ARG;

    /* Get the size of the resource type + '/' + resource ID */
    size_t str_len = strlen(p_json_buffer->resource_type) + 1 + strlen(p_json_buffer->resource_id);

    /* Resource ID should be verified by this point & resource type should be one of 4 static strings, so unlikely to be
     * improperly sized, but check for improper lengths anyway */
    if (unlikely(str_len < (HUE_RESOURCE_TYPE_MIN + HUE_RESOURCE_ID_LENGTH))) {
        ESP_LOGE(tag, "Resource type and/or ID are too short");
        return ESP_ERR_INVALID_SIZE;
    }
    if (unlikely(str_len > (HUE_RESOURCE_TYPE_SIZE + HUE_RESOURCE_ID_LENGTH))) {
        ESP_LOGE(tag, "Resource type and/or ID are too long");
        return ESP_ERR_INVALID_SIZE;
    }

    /* If resource path is already allocated, free before overwriting pointer */
    if (request_handle->resource_path) free(request_handle->resource_path);

    /* Allocate resource path to exactly fit "[resource type]/[resource id]" */
    request_handle->resource_path = calloc(str_len + 1, sizeof(char));
    if (!request_handle->resource_path) {
        ESP_LOGE(tag, "Failed to allocate memory for resource path");
        return ESP_ERR_NO_MEM;
    }

    /* Put "[resource type]/[resource id]" into request resource path */
    int err = snprintf(request_handle->resource_path, str_len + 1, "%s/%s", p_json_buffer->resource_type,
                       p_json_buffer->resource_id);

    /* Verify that resource path has been properly put into buffer */
    if (unlikely((err != str_len) || (strlen(request_handle->resource_path) != str_len))) {
        ESP_LOGE(tag, "Failed to put resource path into request buffer");
        return ESP_ERR_INVALID_SIZE;
    }

    return ESP_OK;
}

static esp_err_t alloc_request_instance(hue_https_request_handle_t* p_request_handle,
                                        hue_json_buffer_t* p_json_buffer) {
    if (HUE_NULL_CHECK(tag, p_request_handle)) return ESP_ERR_INVALID_ARG;
    if (HUE_NULL_CHECK(tag, p_json_buffer)) return ESP_ERR_INVALID_ARG;

    /* Allocate memory for the request instance and set handle value to the instance pointer */
    (*p_request_handle) = malloc(sizeof(hue_https_request_instance_t));
    if (!(*p_request_handle)) {
        ESP_LOGE(tag, "Failed to allocate memory for request instance");
        return ESP_ERR_NO_MEM;
    }

    /* Set internal unallocated buffer pointers to NULL */
    (*p_request_handle)->request_body = NULL;
    (*p_request_handle)->resource_path = NULL;

    /* Allocate and fill request body buffer from p_json_buffer */
    esp_err_t err = alloc_request_body(*p_request_handle, p_json_buffer);
    if (err != ESP_OK) {
        /* Free all potentially allocated resources before returning allocation error code */
        free_request_instance(p_request_handle);
        return err;
    }

    /* Allocate and fill resource path buffer from p_json_buffer */
    err = alloc_resource_path(*p_request_handle, p_json_buffer);
    if (err != ESP_OK) {
        /* Free all potentially allocated resources before returning allocation error code */
        free_request_instance(p_request_handle);
        return err;
    }

    return ESP_OK;
}
